(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{272:function(v,_,t){"use strict";t.r(_);var r=t(38),e=Object(r.a)({},function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"汇编入门必备"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#汇编入门必备","aria-hidden":"true"}},[v._v("#")]),v._v(" 汇编入门必备")]),v._v(" "),t("h3",{attrs:{id:"字-word"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字-word","aria-hidden":"true"}},[v._v("#")]),v._v(" 字(word)")]),v._v(" "),t("p",[v._v("CPU可以处理两种尺寸的数据，即"),t("strong",[v._v("字")]),v._v("(word)和"),t("strong",[v._v("字节")]),v._v("(byte)，CPU和内存之间的数据传送单位通常是一个字长。")]),v._v(" "),t("p",[v._v("我们知道，1byte = 8bit，那么字长又是多少呢？其实字长通常跟CPU的位数相同。例如：64位CPU字长就是64位，即1word = 8byte，寄存器大小也是64位。但是也有个别情况，比如 Intel 80386CPU是32位的，但字长却是16位，即1word = 2byte，这是为了向后兼容80286CPU(16位)。")]),v._v(" "),t("h3",{attrs:{id:"汇编语言分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#汇编语言分类","aria-hidden":"true"}},[v._v("#")]),v._v(" 汇编语言分类")]),v._v(" "),t("p",[v._v("这里主要介绍最常见的两种CPU架构，即ARM架构和Intel架构。ARM架构主要用户移动设备，比如iOS和Android，而Intel架构主要用于台式电脑。每种CPU架构都有其对应的指令集，于是也就有了不同类型的汇编语言。")]),v._v(" "),t("p",[v._v("常见的汇编语言有两种：ARM汇编和x86汇编。而x86汇编按语法格式又分为"),t("a",{attrs:{href:"https://baike.baidu.com/item/%E8%8B%B1%E7%89%B9%E5%B0%94",target:"_blank",rel:"noopener noreferrer"}},[v._v("Intel汇编"),t("OutboundLink")],1),v._v("和"),t("a",{attrs:{href:"https://baike.baidu.com/item/AT&T",target:"_blank",rel:"noopener noreferrer"}},[v._v("AT&T汇编"),t("OutboundLink")],1),v._v("。Intel和AT&T语法区别见下表：")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("项目")]),v._v(" "),t("th",[v._v("Intel")]),v._v(" "),t("th",[v._v("AT&T")]),v._v(" "),t("th",[v._v("说明")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("寄存器名")]),v._v(" "),t("td",[v._v("rax")]),v._v(" "),t("td",[v._v("%rax")]),v._v(" "),t("td",[v._v("AT&T要在寄存器前加%")])]),v._v(" "),t("tr",[t("td",[v._v("操作数顺序")]),v._v(" "),t("td",[v._v("目标数在前"),t("code",[v._v("mov rax, rdx")])]),v._v(" "),t("td",[v._v("目标数在后"),t("code",[v._v("mov %rdx, %rax")])]),v._v(" "),t("td",[v._v("将rdx的值赋给rax")])]),v._v(" "),t("tr",[t("td",[v._v("立即数")]),v._v(" "),t("td",[v._v("原样"),t("code",[v._v("mov rax, 5")])]),v._v(" "),t("td",[v._v("数字前加$"),t("code",[v._v("mov $5, %rax")])]),v._v(" "),t("td",[v._v("将5赋给rax")])]),v._v(" "),t("tr",[t("td",[v._v("十六进制立即数")]),v._v(" "),t("td",[v._v("开头加0结尾加H，例如"),t("code",[v._v("010H")])]),v._v(" "),t("td",[v._v("开头加0x，例如"),t("code",[v._v("0x10")])]),v._v(" "),t("td",[v._v("十六进制数10")])]),v._v(" "),t("tr",[t("td",[v._v("访问内存长度表示")]),v._v(" "),t("td",[v._v("开头加BYTE PTR, WORD PTR, DWORD PTR和QWORD PTR")]),v._v(" "),t("td",[v._v("结尾加b,w,l,q")]),v._v(" "),t("td",[v._v("分别表示字节，字，双字和四字")])]),v._v(" "),t("tr",[t("td",[v._v("引用全局或静态变量var的值")]),v._v(" "),t("td",[v._v("[var]")]),v._v(" "),t("td",[v._v("var")]),v._v(" "),t("td",[v._v("-")])]),v._v(" "),t("tr",[t("td",[v._v("引用全局或静态变量var的地址")]),v._v(" "),t("td",[v._v("var")]),v._v(" "),t("td",[v._v("$var")]),v._v(" "),t("td",[v._v("-")])]),v._v(" "),t("tr",[t("td",[v._v("直接寻址/绝对寻址")]),v._v(" "),t("td",[v._v("[imm]")]),v._v(" "),t("td",[v._v("imm")]),v._v(" "),t("td",[v._v("imm表示立即数")])]),v._v(" "),t("tr",[t("td",[v._v("间接寻址")]),v._v(" "),t("td",[v._v("[reg]")]),v._v(" "),t("td",[v._v("(%reg)")]),v._v(" "),t("td",[v._v("reg表示寄存器")])]),v._v(" "),t("tr",[t("td",[v._v("基址相对寻址")]),v._v(" "),t("td",[v._v("[reg+imm]")]),v._v(" "),t("td",[v._v("imm(%reg)")]),v._v(" "),t("td",[v._v("-")])]),v._v(" "),t("tr",[t("td",[v._v("变址寻址")]),v._v(" "),t("td",[v._v("[base+index] 或 imm[base+index]")]),v._v(" "),t("td",[v._v("(base,index) 或 imm(base+index)")]),v._v(" "),t("td",[v._v("base和index均为寄存器")])]),v._v(" "),t("tr",[t("td",[v._v("比例变址寻址")]),v._v(" "),t("td",[v._v("imm[base+index*scale]")]),v._v(" "),t("td",[v._v("imm(base, index, scale)")]),v._v(" "),t("td",[v._v("scale只能是1, 2, 4, 8其中的一个数字 (1省略不写就是普通变址寻址)")])]),v._v(" "),t("tr",[t("td",[v._v("代码注释")]),v._v(" "),t("td",[v._v("指令和注释用 "),t("strong",[v._v(";")]),v._v(" 分开，例如："),t("code",[v._v("mov rax, rdx ;我是注释")])]),v._v(" "),t("td",[v._v("同Intel汇编")]),v._v(" "),t("td",[v._v("-")])]),v._v(" "),t("tr",[t("td",[v._v("所在平台")]),v._v(" "),t("td",[v._v("Windows")]),v._v(" "),t("td",[v._v("Unix")]),v._v(" "),t("td",[v._v("-")])])])]),v._v(" "),t("p",[v._v("对于iOS开发来说，iOS真机上的汇编格式为ARM而模拟器上的格式则为AT&T，所以我们重点掌握下这两种汇编即可。ARM汇编的操作数顺序跟Intel是一样的，这里就不详细展开了，具体可以直接看"),t("a",{attrs:{href:"http://infocenter.arm.com/help/index.jsp",target:"_blank",rel:"noopener noreferrer"}},[v._v("官方文档"),t("OutboundLink")],1),v._v("。")]),v._v(" "),t("h3",{attrs:{id:"寻址方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#寻址方式","aria-hidden":"true"}},[v._v("#")]),v._v(" 寻址方式")]),v._v(" "),t("p",[v._v("顾名思义，寻址方式就是CPU根据指令中给出的地址信息来寻找有效地址的方式，是确定本条指令的数据地址以及下一条要执行的指令地址的方法。寻址方式分为两类，即"),t("strong",[v._v("指令寻址方式")]),v._v("和"),t("strong",[v._v("数据寻址方式")]),v._v("。")]),v._v(" "),t("h4",{attrs:{id:"_0x1-指令寻址方式："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_0x1-指令寻址方式：","aria-hidden":"true"}},[v._v("#")]),v._v(" 0x1. 指令寻址方式：")]),v._v(" "),t("p",[v._v("指令地址在内存中是按顺序安排的，当执行一段程序时，通常是一条指令接着一条指令地顺序进行。也就是说，从内存中取出第一条指令，然后执行；接着从内存中再取出第二条指令，继续执行；依次类推。这种顺序执行的过程，称为"),t("strong",[v._v("顺序寻址方式")]),v._v("。为此，必须使用程序计数器PC（ARM下叫PC，x86下叫IP）来计数指令的地址("),t("strong",[v._v("Tip1")]),v._v(")。")]),v._v(" "),t("p",[v._v("当程序转移执行的顺序时，指令的寻址就采取"),t("strong",[v._v("跳跃寻址方式")]),v._v("。所谓跳跃，就是下条指令的地址不再由PC给出，而是由本条指令给出。跳跃后，按新的指令地址开始顺序执行。因此，PC的内容也必须改变，以便能及时跟踪新的指令地址。")]),v._v(" "),t("div",{staticClass:"tip custom-block"},[t("p",[v._v("Tip1: 当执行一条指令时，首先需要根据PC中存放的指令地址，将指令由内存取到指令寄存器中，与此同时，PC中的地址或自动加1或由转移指针给出下一条指令的地址。")])]),v._v(" "),t("h4",{attrs:{id:"_0x2-数据寻址方式："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_0x2-数据寻址方式：","aria-hidden":"true"}},[v._v("#")]),v._v(" 0x2. 数据寻址方式：")]),v._v(" "),t("p",[v._v("数据寻址方式比较多，这里只列出几种常见的寻址方式，基本上都是汇编语言里经常用到的。")]),v._v(" "),t("p",[t("strong",[v._v("0x21. 立即寻址:")])]),v._v(" "),t("p",[v._v("指令的地址字段给出的不是操作数的地址，而是操作数本身，由于不需要访问内存取数，所以指令执行时间很短(Note1)。例如："),t("code",[v._v("mov 0x123, %rax")])]),v._v(" "),t("div",{staticClass:"warning custom-block"},[t("p",[v._v("Note1:\n立即数只能作为源操作数，而不能作为目的操作数。")])]),v._v(" "),t("p",[t("strong",[v._v("0x22. 直接寻址:")])]),v._v(" "),t("p",[v._v("指令的地址字段给出的是操作数的内存地址。因为直接给出操作数的内存地址而不需要经过某种变换，所以称为直接寻址。")]),v._v(" "),t("p",[t("strong",[v._v("0x23. 间接寻址:")])]),v._v(" "),t("p",[v._v("间接寻址是相对直接寻址而言的，在间接寻址的情况下，指令地址字段给出的地址，是个形式地址不是操作数的真正地址，或者说该地址单元中的内容才是操作数的有效地址。")]),v._v(" "),t("p",[t("strong",[v._v("0x24. 相对寻址:")])]),v._v(" "),t("p",[v._v('相对寻址是把PC的内容加上指令格式中的形式地址D而形成操作数的有效地址。"相对"寻址，就是相对于当前的指令地址而言，好处是程序员无须用指令的绝对地址编程，因而所编程序可以放在内存的任何地方。')]),v._v(" "),t("p",[t("strong",[v._v("0x25. 基址寻址:")])]),v._v(" "),t("p",[v._v("在基址寻址方式中将CPU中的基址寄存器的内容，加上变址寄存器的内容而形成操作数的有效地址。基址寻址的优点是可以扩大寻址能力。")]),v._v(" "),t("p",[t("strong",[v._v("0x26. 变址寻址:")])]),v._v(" "),t("p",[v._v("把CPU中某个变址寄存器的内容与偏移量D相加来形成操作数有效地址。参见上表👆")]),v._v(" "),t("p",[t("strong",[v._v("0x27. 寄存器寻址:")])]),v._v(" "),t("p",[v._v("操作数不放在内存中，而是把操作数本身的值放在CPU的通用寄存器中。")]),v._v(" "),t("p",[t("strong",[v._v("0x28. 寄存器间接寻址:")])]),v._v(" "),t("p",[v._v("把操作数地址放在CPU的通用寄存器中，而操作数本身的值则放在内存中。")]),v._v(" "),t("hr"),v._v(" "),t("p",[t("strong",[v._v("参考资料:")])]),v._v(" "),t("p",[t("a",{attrs:{href:"https://css.csail.mit.edu/6.858/2014/readings/i386/s02_03.htm",target:"_blank",rel:"noopener noreferrer"}},[v._v("https://Intel 80386 Reference Programmer's Manual"),t("OutboundLink")],1),v._v(" "),t("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80",target:"_blank",rel:"noopener noreferrer"}},[v._v("https://en.wikipedia.org/wiki/Assembly_language"),t("OutboundLink")],1),v._v(" "),t("a",{attrs:{href:"https://baike.baidu.com/item/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F",target:"_blank",rel:"noopener noreferrer"}},[v._v("https://baike.baidu.com/item/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"),t("OutboundLink")],1)])])},[],!1,null,null,null);_.default=e.exports}}]);