(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{293:function(a,t,e){"use strict";e.r(t);var r=e(38),_=Object(r.a)({},function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"关于内存的几个小概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关于内存的几个小概念","aria-hidden":"true"}},[a._v("#")]),a._v(" 关于内存的几个小概念")]),a._v(" "),e("h3",{attrs:{id:"_1-后备存储-backup-storage"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-后备存储-backup-storage","aria-hidden":"true"}},[a._v("#")]),a._v(" 1. 后备存储(backup storage)")]),a._v(" "),e("p",[a._v("在macOS中，使用磁盘来保存当前未使用的数据。当内存已满时，未使用的内存段会被写入磁盘，为当下需要的数据腾出空间。存储未使用数据的磁盘部分称为"),e("strong",[a._v("后备存储")]),a._v("。")]),a._v(" "),e("p",[a._v("然而iOS并不支持后备存储。在iPhone应用程序中，已经存在于磁盘上的只读数据只是简单地从内存中移除，并根据需要从磁盘重新加载。操作系统永远不会把可写数据从内存中移除。相反，如果空闲内存低于某个阈值时，系统会要求正在运行的应用程序自动释放内存，为新数据腾出空间。无法释放足够内存的话，应用程序将被终止。")]),a._v(" "),e("h3",{attrs:{id:"_2-页-page"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-页-page","aria-hidden":"true"}},[a._v("#")]),a._v(" 2. 页(page)")]),a._v(" "),e("p",[a._v("为了摆脱物理内存(RAM)的限制，虚拟管理器为每个进程创建一个逻辑地址空间(也叫虚拟地址空间)，并将其划分为大小相同的内存块，称之为"),e("strong",[a._v("页")]),a._v("。物理内存也会被划分为大小相同的页。在macOS和iOS早期版本中，一个页大小是4KB，而在iOS的后续版本中，页大小扩大到了16KB。可通过函数"),e("code",[a._v("getpagesize()")]),a._v("获取页大小。")]),a._v(" "),e("h3",{attrs:{id:"_3-页入-页出-page-in-page-out"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-页入-页出-page-in-page-out","aria-hidden":"true"}},[a._v("#")]),a._v(" 3. 页入/页出(page-in/page-out)")]),a._v(" "),e("p",[a._v("将数据从物理内存移动到后备存储称为"),e("strong",[a._v("页出")]),a._v("(或“换出”)；而将数据从后备存储移回到物理内存称为"),e("strong",[a._v("页入")]),a._v("(或“换入”)。在iOS中，没有后备存储，因此页永远不会被换出到磁盘，但是只读页仍然可以根据需要从磁盘换入。")]),a._v(" "),e("h3",{attrs:{id:"_4-页错误-page-fault"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-页错误-page-fault","aria-hidden":"true"}},[a._v("#")]),a._v(" 4. 页错误 (page-fault)")]),a._v(" "),e("p",[a._v("CPU及其MMU(内存管理单元)维护了一个"),e("router-link",{attrs:{to:"/others/paging.html"}},[a._v("页表")]),a._v("，用于将程序的虚拟地址空间中的页，映射到物理内存中，当程序代码访问内存中的地址时，MMU使用页表将指定的虚拟地址转换为实际的物理内存地址。如果应用程序访问某一内存地址，发现该地址所在的页并没有加载到物理内存中时，就会发生"),e("strong",[a._v("页错误")]),a._v("。此时，虚拟内存系统会调用page-fault handler来立即响应错误，page-fault handler会停止当前正在执行的代码，然后在物理内存中分配一个物理页，将该“错误页”所对应的数据从磁盘加载到内存中("),e("strong",[e("font",[a._v("Tip1:")])],1),a._v(")，接着更新页表，即设置虚拟页和物理页的映射关系，最后将控制权返回给程序的代码，从刚才页错误的位置重新开始执行。")],1),a._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",[e("strong",[e("font",[a._v("Tip1:")])],1),a._v("\n因为可执行文件跟虚拟地址空间的映射关系，所以page-fault handler知道该“错误页”在可执行文件中的位置，也就能在磁盘中找到该页所对应的数据。")])]),a._v(" "),e("p",[a._v("关于可执行文件、虚拟地址空间、物理内存三者之间的映射关系，如下图：")]),a._v(" "),e("p",[e("img",{attrs:{src:"/resources/pagemap.jpeg",alt:"映射关系"}})]),a._v(" "),e("h3",{attrs:{id:"_5-页类型-page-types"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-页类型-page-types","aria-hidden":"true"}},[a._v("#")]),a._v(" 5. 页类型(page types)")]),a._v(" "),e("p",[a._v("页的类型分为clean和dirty。基于只读文件被加载到内存中的page即为clean，比如：framework中__DATA_CONST部分、可执行文件、以及其他通过"),e("code",[a._v("mmap")]),a._v("映射到内存的文件。由于这种page是加载只读文件，因此可以在物理内存紧张时被iOS卸载，并且之后可根据需要重新加载到内存。除clean page之外，其他都是dirty page。它们的共同点是在磁盘中没有对应的文件，比如："),e("code",[a._v("malloc")]),a._v("出的内存(堆上的对象)、图片解码缓冲数据等。")]),a._v(" "),e("p",[a._v("关于内存占用，附一张WWDC视屏截图：")]),a._v(" "),e("p",[e("img",{attrs:{src:"/resources/memoryfootprint.png",alt:""}})]),a._v(" "),e("hr"),a._v(" "),e("p",[e("strong",[a._v("参考资料：")]),e("a",{attrs:{href:"https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://developer.apple.com/Articles/AboutMemory.html"),e("OutboundLink")],1)])])},[],!1,null,null,null);t.default=_.exports}}]);